//
//  CallingViewController.swift
//  IOS-combine
//
//  Created by usama farooq on 02/09/2021.
//  Copyright (c) 2021 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the üêç VIPER generator
//

import UIKit
import iOSSDKStreaming



final class CallingViewController: UIViewController {

    // MARK: - Public properties -
   
    var groupCallingView: GroupCallingUpdatedView?
    var incomingCallingView: IncomingCall?
    var broadcastView: BroadcastView?
    var counter = 0
    var timer = Timer()

    var presenter: CallingPresenterInterface!

    // MARK: - Lifecycle -

    override func viewDidLoad() {
        super.viewDidLoad()
        bindPresenter()
        presenter.viewModelDidLoad()
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        presenter.viewModelWillAppear()
    }
    
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
    }
    
    func bindPresenter() {
        presenter.output = { output in
            switch output {
            case .update(let session):
                switch session.callType {
                case .onetomany:
                    guard self.broadcastView != nil else {
                        self.loadBroadcastView(session: session)
                        if session.broadcastType == .publicURL {
                            self.broadcastView?.updateURL(with: AppDelegate.appDelegate.publicURL)
                        }
                        return
                    }
                    self.broadcastView?.update(for: session)
                case .manytomany, .onetoone:
                    guard self.groupCallingView != nil else {
                        self.loadGroupCallingView(session: session)
                        return
                    }
                    self.groupCallingView?.updateView(for: session)
                }
           
            case .configureRemote(let streams, let session):
                self.configureRemote(streams: streams, session: session)
            case .loadIncomingCallView(let session, let user):
                self.loadIncomingCallView(session: session, contact: user)
            case .loadBroadcastView(let session):
                guard self.broadcastView != nil else {
                    self.loadBroadcastView(session: session)
                    return
                }
                self.broadcastView?.update(for: session)
            case .dismissCallView:
                self.dismiss(animated: true, completion: nil)
            case .configureLocal(let renderer, let session):
                self.configureLocalView(rendrer: renderer, session: session)
            case .fetchonetomany(let session, let url):
                guard self.broadcastView != nil else {
                    self.loadBroadcastView(session: session)
                    self.broadcastView?.updateURL(with: AppDelegate.appDelegate.publicURL)
                    return
                }
                self.broadcastView?.update(for: session)
               
            case .updateURL(let url):
                self.broadcastView?.updateURL(with: url)
            default:
                break
            }
        }
    }
    
    private func updateVideoView(session: VTokBaseSession) {
        switch session.callType {
        case .onetoone, .manytomany:
            guard let groupCallingView = groupCallingView else {return}
           // groupCallingView.updateAudioVideoview(for: session)
        case .onetomany:
            guard let broadcastView = broadcastView else {return}
           // broadcastView.updateView(with: session)
        }
    }
    
    private func configureLocalView(rendrer: UIView, session: VTokBaseSession) {
        switch session.callType {
        case .onetoone, .manytomany:
            guard let groupCallingView = groupCallingView else {return}
//            groupCallingView.configureLocal(view: rendrer)
           groupCallingView.session = session
        case .onetomany:
            guard let broadcastView = broadcastView else {return}
            broadcastView.setViewsForOutGoing(session: session, renderer: rendrer)
        }
    }
    private func configureView(for session: VTokBaseSession) {
        switch session.callType {
        case .onetoone, .manytomany:
            guard let groupCallingView = groupCallingView else {return}
            groupCallingView.updateView(for: session)
        case .onetomany:
            guard let broadcastView = broadcastView else {return}
           // broadcastView.updateView(with: session)
            
        }
        
    }
    
    private func handleHangup(status: Bool) {
        guard let groupCallingView = groupCallingView else {return}
      //  groupCallingView.handleHanup(status: status)
    }
    
    private func configureRemote(streams: [UserStream], session: VTokBaseSession) {
        switch session.callType {
        case .manytomany, .onetoone:
            guard let groupCallingView = groupCallingView else {return}
            groupCallingView.updateDataSource(with: streams, session: session)
        case .onetomany:
            guard let broadcastView = self.broadcastView else {return}
            broadcastView.configureView(with: streams, and: session)
        }
       
    }
    
    private func loadBroadcastView(session: VTokBaseSession) {
        broadcastView = BroadcastView.loadView()
        guard let broadcastView = self.broadcastView else {return}
    //    broadcastView.updateView(with: session)
        if session.associatedSessionUUID != nil { broadcastView.smallLocalView.isHidden = false}
        broadcastView.update(for: session)
        broadcastView.delegate = self
        broadcastView.translatesAutoresizingMaskIntoConstraints = false
        self.view.addSubview(broadcastView)
        broadcastView.fixInSuperView()
    }
    
    private func loadGroupCallingView(session: VTokBaseSession) {
        let view = GroupCallingUpdatedView.getView()
        
        self.groupCallingView = view
        groupCallingView?.users = presenter.users
        guard let groupCallingView = self.groupCallingView else {return}
        groupCallingView.session = presenter.session
//        groupCallingView.loadViewFor(mediaType: mediaType)
        groupCallingView.updateView(for: session)
        groupCallingView.delegate = self
        groupCallingView.translatesAutoresizingMaskIntoConstraints = false
        self.view.addSubview(groupCallingView)
        
        NSLayoutConstraint.activate([
            groupCallingView.leadingAnchor.constraint(equalTo: self.view.leadingAnchor),
            groupCallingView.trailingAnchor.constraint(equalTo:self.view.trailingAnchor),
            groupCallingView.topAnchor.constraint(equalTo: self.view.topAnchor),
            groupCallingView.bottomAnchor.constraint(equalTo: self.view.bottomAnchor)
        ])
    }
    
    private func loadIncomingCallView(session: VTokBaseSession, contact: User) {
        let view = IncomingCall.loadView()
        self.incomingCallingView = view
        
        guard let incomingCallingView = self.incomingCallingView else {return}
        view.configureView(baseSession: session, user: contact)
        view.session = session
        incomingCallingView.delegate = self
        incomingCallingView.translatesAutoresizingMaskIntoConstraints = false
        self.view.addSubview(incomingCallingView)
        
        NSLayoutConstraint.activate([
            incomingCallingView.leadingAnchor.constraint(equalTo: self.view.leadingAnchor),
            incomingCallingView.trailingAnchor.constraint(equalTo:self.view.trailingAnchor),
            incomingCallingView.topAnchor.constraint(equalTo: self.view.topAnchor),
            incomingCallingView.bottomAnchor.constraint(equalTo: self.view.bottomAnchor)
        ])
    }

}

// MARK: - Extensions -

extension CallingViewController: CallingViewInterface {
    private func updateWith(URL: String) {
        guard let broadCastView = broadcastView else {return}
        broadCastView.updateURL(with: URL)
    }
}


extension CallingViewController: VideoDelegate {
    func didTapVideo(for baseSession: VTokBaseSession, state: VideoState) {
        presenter.disableVideo(session: baseSession, state: state)
    }

    func didTapMute(for baseSession: VTokBaseSession, state: AudioState) {
        presenter.mute(session: baseSession, state: state)
    }

    func didTapEnd(for baseSession: VTokBaseSession) {
        presenter.hangupCall(session: baseSession)
    }

    func didTapFlip(for baseSession: VTokBaseSession, type: CameraType) {
        presenter.flipCamera(session: baseSession, state: type)
    }

    func didTapSpeaker(baseSession: VTokBaseSession, state: SpeakerState) {
        presenter.speaker(session: baseSession, state: state)
    }
    
    func didTapDismiss() {
        self.dismiss(animated: true, completion: nil)
    }

}

extension CallingViewController: IncomingCallDelegate {
    func didReject(session: VTokBaseSession) {
        presenter.rejectCall(session: session)
    }
    
    func didAccept(session: VTokBaseSession) {
        presenter.acceptCall(session: session)
    }
    
    
}
extension CallingViewController: BroadcastDelegate {

    func didTapStream(with state: StreamStatus) {
      //  viewModel.didTapStream(with: state)
}
    
    func didTapRoute() {
        AVAudioSession().ChangeAudioOutput(presenterViewController: self)

    }
    
   
    
    func didTapMuteSS(for baseSession: VTokBaseSession, state: AudioState) {
    //    viewModel.mute(session: baseSession, state: state)
        presenter.mute(session: baseSession, state: state)
    }
    
    func didTapHangUp(for session: VTokBaseSession) {
        presenter.hangupCall(session: session)
      //  viewModel.hangupCall(session: session)
    }
    
    func didTapSpeaker(for session: VTokBaseSession, state: SpeakerState) {
     //   viewModel.speaker(session: session, state: state)
        presenter.speaker(session: session, state: state)
        
    }
    
    func didTapFlipCamera(for session: VTokBaseSession, type: CameraType) {
     //   viewModel.flipCamera(session: session, state: type)
        presenter.flipCamera(session: session, state: type)
    }
    
    func didTapVideo(for session: VTokBaseSession, type: VideoState) {
     //   viewModel.disableVideo(session: session, state: type)
        presenter.disableVideo(session: session, state: type)
    }


}
