//
//  ChatInteractor.swift
//  IOS-combine
//
//  Created by usama farooq on 01/09/2021.
//  Copyright © 2021 VDOTOK. All rights reserved.
//
//  This file was generated by the 🐍 VIPER generator
//

import Foundation
import iOSSDKConnect
import WatchConnectivity
import HealthKit

final class ChatInteractor: NSObject {
    

    var mqttClient: ChatClient?
    let healthStore = HKHealthStore()
    var user: User
    var group: Group
    var broadcastData: BroadcastData?
    var messages: [ChatMessage]
    var healthManager: HealthManager
    weak var presenter: ChatInteractorToPresenter? {didSet {
        presenter?.updateGroup(with: group, user: user, messages: messages)
    }}
    var session: WCSession
    
    init(mqttClient: ChatClient, user: User, group: Group, messages:[ChatMessage],session: WCSession = .default, healthManager: HealthManager) {
        
        self.mqttClient = mqttClient
        self.user = user
        self.group = group
        self.messages = messages
        self.session = session
        self.healthManager = healthManager
        super.init()
        setupDelegates()
        session.delegate = self
        session.activate()
        
    }
    
    
}

// MARK: - Extensions -

extension ChatInteractor: ChatInteractorInterface {
    
    func setupDelegates() {
        mqttClient?.setReceiptAcknowledge(receiptAcknowledge: self)
        mqttClient?.setReceiptDelegate(receiptDelegate: self)
    
    }
    
    func sendMessage(with text: String, type: String) {
        let now = Date()
        let timeInterval = now.millisecondsSince1970
        let message = MessageModel(id: UUID().uuidString,
                                   to: group.channelName,
                                   key: group.channelKey,
                                   from: user.refID,
                                   type: type,
                                   content: text.prefix(400).description,
                                   size: 0,
                                   isGroupMessage: false,
                                   status: 0,
                                   date: timeInterval)
        mqttClient?.publish(message: message)
        dispatchPackage(start: false)
    }
    
    func dispatchPackage(start: Bool) {
        if start {
            let messageModel = MessageModel(id: UUID().uuidString,
                                            to: group.channelName,
                                            key: group.channelKey,
                                            from: user.refID,
                                            type: "typing",
                                            content: "1",
                                            size: 0,
                                            isGroupMessage: false,
                                            status: 0,
                                            date: 1622801248314)
            mqttClient?.publish(message: messageModel)
        } else {
            let messageModel = MessageModel(id: UUID().uuidString,
                                            to: group.channelName,
                                            key: group.channelKey,
                                            from: user.refID,
                                            type: "typing",
                                            content: "0",
                                            size: 0,
                                            isGroupMessage: false,
                                            status: 0,
                                            date: 1622801248314)
            mqttClient?.publish(message: messageModel)
        }
    }
    
    func sendSeenMessage(message: ChatMessage, row: Int) {
        
        if message.status == .delivered  {
            let receipt = ReceiptModel(type: ReceiptType.seen.rawValue,
                                       key: group.channelKey, date: 1622801248314,
                                       messageId: message.id,
                                       from: user.fullName,
                                       topic: group.channelName)
            if user.fullName != message.sender {
                self.messages[row].status = .seen
            }
            self.send(receipt: receipt, status: .seen, isMyMessage: user.fullName == message.sender)
        }
        
    }
    
    func receivedMessage(userInfo: [String: AnyObject]) {
        let content = userInfo[Constants.messageKey] as! String
        let username = userInfo[Constants.usernameKey] as! String
        let id = userInfo[Constants.idKey] as? String ?? UUID().uuidString
        let fileType = userInfo[Constants.fileKey] as? URL
        let mediaType = userInfo[Constants.mediaType] as? Int
        let date = userInfo[Constants.date] as! UInt64
        let messageType = userInfo[Constants.mediaType] as? String
        
        
        guard let topic = userInfo[Constants.topicKey] as? String,
              topic == group.channelName
        else { return }
        if content.contains("left") {
            return
        } else if content.contains("joined"){
            return
        }
        
        if content.isEmpty {
            if let mediaType = mediaType {
                messages.append(ChatMessage(id: id, sender: username, content: "", status: user.refID == username ? .sent : .delivered, fileType: fileType, mediaType: MediaType(rawValue: mediaType), date: date))
                ProgressHud.hide()
            } else {
                messages.append(ChatMessage(id: id, sender: username, content: "", status: .delivered, fileType: fileType, date: date))
            }
           
            presenter?.update(messages: messages)
           // chatOutput?(.reload)
            
            return
        }
        
        if let messageType = messageType {
            
            if messageType == "sensorDataFetched" || messageType == "fetchingSensorData" {
                if username != user.refID {
                    
                    switch content {
                    case SensorTypeConstants.BLOOD_OXYGEN:
                        sendOxygenLevel()
                        return
                    case SensorTypeConstants.HEART_RATE:
                        session.sendMessage(["message": "get_heartrate"], replyHandler: nil) { error in
                            print(error)
                        }
                        return
                    case SensorTypeConstants.STEP_COUNT:
                        getStepsCount(forSpecificDate: Date()) { [weak self] steps in
                            guard let self = self else {return}
                            self.sendMessage(with: "\(steps)", type: "sensorDataFetched")
                        }
                        return
                    default:
                        break
                    }
                }
            }
        }

        if content.contains("#sc#") || content.contains("#hr#") || content.contains("#bo#") {
            return
        }
        let chatMessage = ChatMessage(id: id,sender: username, content: content, status: user.refID == username ? .sent :.delivered, date: date)
        messages.append(chatMessage)
        presenter?.update(messages: messages)
      //  chatOutput?(.reload)
       
        
    }
    
    func publish(file data: Data, with ext: String, type: Int) {
        let now = Date()
        let timeInterval = now.millisecondsSince1970
        mqttClient?.publish(file: data, fileExt: ext, topic: group.channelName, key: group.channelKey, from: user.refID, type: type, date: timeInterval)
        ProgressHud.show()
    }
    func itemAt(row: Int) -> (ChatMessage,CellType) {
        
        if messages[row].sender != user.refID && messages[row].content == "" {
            
            switch messages[row].mediaType {
            case .image:
                return (messages[row], .incomingImage)
            case .file:
                return (messages[row], .incomingAttachment)
            case .video:
                return (messages[row], .incomingAttachment)
            case .audio:
                return (messages[row], .incomingAttachment)
            default:
                break
            }
           
        } else if messages[row].sender == user.refID && messages[row].content == ""  {
            
            switch messages[row].mediaType {
            case .image:
                return (messages[row], .outGoingImage)
            case .file:
                return (messages[row], .outgoingAttachment)
            case .video:
                return (messages[row], .outgoingAttachment)
            case .audio:
                return (messages[row], .outgoingAttachment)
            default:
                break
            }
        }
        if messages[row].sender == user.refID {
            return (messages[row], .outGoingText)
        }else {
            return (messages[row], .incomingText)
        }
    }
}

extension ChatInteractor: ReceiptAcknowledge {
    func didReceive(receipt: Receipt, status: ReceiptType) {
        guard user.fullName != receipt.from, let messageIndex = self.messages.firstIndex(where: {$0.id == receipt.messageId}) else {return}
        if  user.refID != receipt.from {
            messages[messageIndex].status = status
           // self.output?(.reloadCell(indexPath: IndexPath(row: messageIndex, section: 0)))
            self.presenter?.reloadCell(with: IndexPath(row: messageIndex, section: 0))
        }
    }
    }
    
    


extension ChatInteractor: ReceiptDelegate {
    func send(receipt: Receipt, status: ReceiptType, isMyMessage: Bool) {
        guard !isMyMessage else {return}
        mqttClient?.publish(receipt: receipt)
        print("send receipt \(status) \(receipt.from)")
    }
    
    
}

extension ChatInteractor {
    func moveToCallingView(broadcastData: BroadcastData) {
        let groupId = group.id
        
        let userInfo: [AnyHashable: Any]? = ["callType": NotifyCallType.cameraBroadcast.callType,
                                             "groupId": groupId,
                                             "broadcastData": broadcastData,
                                             "participants": group.participants]
        NotificationCenter.default.post(name: NotifyCallType.notificationName, object: userInfo)
    }
    
    func moveToSSView(broadcastData: BroadcastData) {
        let groupId = group.id
        let userInfo: [AnyHashable: Any]? = ["callType": NotifyCallType.broadcast.callType,
                                             "groupId": groupId,
                                             "broadcastData": broadcastData,
                                             "participants": group.participants]
        NotificationCenter.default.post(name: NotifyCallType.notificationName, object: userInfo)
    }
}

extension ChatInteractor: WCSessionDelegate {
    func session(_ session: WCSession, activationDidCompleteWith activationState: WCSessionActivationState, error: Error?) {
        switch activationState {
        case .activated:
            print("activated")
        case .inactive:
            print("inactive")
        case .notActivated:
            print("notActivated")
        default:
             break
        }
    }
    
    func sessionDidBecomeInactive(_ session: WCSession) {
        
    }
    
    func sessionDidDeactivate(_ session: WCSession) {
        
    }
    
    func session(_ session: WCSession, didReceiveMessage message: [String : Any]) {
        
        guard let heartRate = message["heartRate"] as? Int else {return}
        sendMessage(with: "\(heartRate)")
    }
}


extension ChatInteractor {
    func getStepsCount(forSpecificDate:Date, completion: @escaping (Double) -> Void) {
            let stepsQuantityType = HKQuantityType.quantityType(forIdentifier: .stepCount)!
            let (start, end) = self.getWholeDate(date: forSpecificDate)

            let predicate = HKQuery.predicateForSamples(withStart: start, end: end, options: .strictStartDate)

            let query = HKStatisticsQuery(quantityType: stepsQuantityType, quantitySamplePredicate: predicate, options: .cumulativeSum) { _, result, _ in
                guard let result = result, let sum = result.sumQuantity() else {
                    completion(0.0)
                    return
                }
                completion(sum.doubleValue(for: HKUnit.count()))
            }

            self.healthStore.execute(query)
        }

        func getWholeDate(date : Date) -> (startDate:Date, endDate: Date) {
            var startDate = date
            var length = TimeInterval()
            _ = Calendar.current.dateInterval(of: .day, start: &startDate, interval: &length, for: startDate)
            let endDate:Date = startDate.addingTimeInterval(length)
            return (startDate,endDate)
        }
    
    func getHealthKitPermission() {

     
            guard HKHealthStore.isHealthDataAvailable() else {
                return
            }

            let stepsCount = HKObjectType.quantityType(forIdentifier: HKQuantityTypeIdentifier.stepCount)!

            self.healthStore.requestAuthorization(toShare: [], read: [stepsCount]) { (success, error) in
                if success {
                    print("Permission accept.")
                }
                else {
                    if error != nil {
                        print(error ?? "")
                    }
                    print("Permission denied.")
                }
            }
        
    }
    public func getOxygenLevel(completion: @escaping (Double?, Error?) -> Void) {

        guard let oxygenQuantityType = HKQuantityType.quantityType(forIdentifier: .oxygenSaturation) else {
            fatalError("*** Unable to get oxygen saturation on this device ***")
        }

        HKHealthStore().requestAuthorization(toShare: nil, read: [oxygenQuantityType]) { (success, error) in

            guard error == nil, success == true else {
                completion(nil, error)
                return
            }

            let predicate = HKQuery.predicateForSamples(withStart: Date.distantPast, end: Date(), options: .strictEndDate)
            let query = HKStatisticsQuery(quantityType: oxygenQuantityType,
                                          quantitySamplePredicate: predicate,
                                          options: .mostRecent) { query, result, error in

                DispatchQueue.main.async {

                    if let err = error {
                        completion(nil, err)
                    } else {
                        guard let level = result, let sum = level.mostRecentQuantity() else {
                            completion(nil, error)
                            return
                        }
                        print("Quantity : ", sum)   // It prints 97 % and I need 97 only

                        let measureUnit0 = HKUnit(from: "%")
                        let count0 = sum.doubleValue(for: measureUnit0)
                        print("Count 0 : ", count0)   // It pronts 0.97 and I need 97 only

                        let measureUnit1 = HKUnit.count().unitMultiplied(by: HKUnit.percent())
                        let count1 = sum.doubleValue(for: measureUnit1)
                        print("Count 1 : ", count1)   // It pronts 0.97 and I need 97 only

                        let measureUnit2 = HKUnit.percent()
                        let count2 = sum.doubleValue(for: measureUnit2)
                        print("Count 2 : ", count2)   // It pronts 0.97 and I need 97 only

                        let measureUnit3 = HKUnit.count()
                        let count3 = sum.doubleValue(for: measureUnit3)
                        print("Count 3 : ", count3)   // It pronts 0.97 and I need 97 only

                        completion(count0 * 100.0, nil)
                    }
                }
            }
            HKHealthStore().execute(query)
        }
    }
    
    func sendOxygenLevel() {
        getOxygenLevel {[weak self] oxygen, error in
            guard let self = self,let  oxygen = oxygen else {return}
            self.sendMessage(with: "\(oxygen)", type: "sensorDataFetched")
        }
    }
    
    private func process(_ samples: [HKQuantitySample], type: HKQuantityTypeIdentifier) {
         var lastOxygenRate = ""
         for sample in samples {
             if type == .oxygenSaturation {
                 lastOxygenRate = sample.quantity.description
             }
             
         }
        print(lastOxygenRate)
     }
}
